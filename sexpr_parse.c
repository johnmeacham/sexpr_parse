/* Generated by re2c 3.1 on Sat Feb 14 23:28:14 2026 */
#line 1 "sexpr_parse.c.re"
#include "sexpr_parse.h"
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdarg.h>


static void
push(struct parse_state *ps,  sp_cell_t c)
{
        sp_cell_t *ts = ps->stack + ps->sptr++;
        struct centry *ctop =  ps->control_stack + ps->csptr - 1;
        *ts = c;
        while (ctop->unary && ps->sptr - 1 == ctop->depth) {
                *ts = sp_unary(ps, ctop->what, *ts);
                ctop--; ps->csptr--;
        }
}


static void
push_control(struct parse_state *ps, char control)
{
        struct centry *ctop = ps->control_stack + ps->csptr++;
        ctop->what = control;
        ctop->unary = !strchr("([{.", control);
        ctop->depth = ps->sptr;
}


static int error(struct parse_state *ps, char *s, ...)
{
        ps->error++;
        char errbuf[128];
        va_list ap;
        va_start(ap, s);
        vsnprintf(errbuf, sizeof(errbuf), s, ap);
        va_end(ap);
        return sp_error(ps, ps->fname, ps->lineno + 1, errbuf);
}

#define OC(x,y) ((x) << 8 | (y))

static int
close_enclosed(struct parse_state *ps, char control)
{
        struct centry *ctop = ps->control_stack + ps->csptr - 1;
        bool is_cons = false;
        sp_cell_t cdr = 0;
        int sptr = ps->sptr, err = 0;
        if (ctop->what == '.') {
                ps->csptr--;
                int len = sptr - ctop->depth;
                if (len != 1) {
                        err = error(ps, "dot must be followed by exactly one item");
                } else {
                        cdr = ps->stack[--sptr];
                        is_cons = true;
                }
                ctop--;
        }
        switch (OC(ctop->what, control)) {
        case OC('(', ']'):
        case OC('(', '}'):
        case OC('{', ')'):
        case OC('{', ']'):
        case OC('[', ')'):
        case OC('[', '}'):
                err |=  error(ps, "mismatched delimiters '%c' '%c'", ctop->what, control);
        case OC('(', ')'):
        case OC('[', ']'):
        case OC('{', '}'):
                ps->csptr--;
                int len = sptr - ctop->depth;
                sp_cell_t v =
                        is_cons && !len ? cdr :
                        is_cons ? sp_cons(ps, ctop->what, &ps->stack[sptr - len], len, cdr) :
                        sp_list(ps, ctop->what, &ps->stack[sptr - len], len);
                ps->sptr = sptr - len;
                push(ps, v);
                return err;
        default:
                return err ? err : error(ps, "unexpected closing '%c'", control);
        }
}


int
sp_scan(struct parse_state *ps, char *start)
{
        ps->cursor = ps->start = start;
        char *t;
        int err = 0;
        char *YYMARKER;
        while (!err) {
                t = ps->cursor;
                
#line 103 "sexpr_parse.c"
		{
			unsigned char curr;
			unsigned int yyaccept = 0;
			curr = (unsigned char)*ps->cursor;
			switch (curr) {
				case 0x00: goto sp_scan1;
				case '\t':
				case '\r':
				case ' ': goto sp_scan4;
				case '\n': goto sp_scan6;
				case '!':
				case '$':
				case '%':
				case '&':
				case '*':
				case '/':
				case ':':
				case '<':
				case '=':
				case '>':
				case '?':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '^':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z':
				case '~': goto sp_scan7;
				case '"': goto sp_scan9;
				case '#': goto sp_scan10;
				case '\'':
				case '(':
				case '[':
				case '`':
				case '{': goto sp_scan12;
				case ')':
				case ']':
				case '}': goto sp_scan13;
				case '+': goto sp_scan14;
				case ',': goto sp_scan15;
				case '-': goto sp_scan16;
				case '.': goto sp_scan18;
				case '0': goto sp_scan19;
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto sp_scan21;
				case ';': goto sp_scan22;
				default: goto sp_scan2;
			}
sp_scan1:
			++ps->cursor;
#line 116 "sexpr_parse.c.re"
			{ err = 1; break; }
#line 211 "sexpr_parse.c"
sp_scan2:
			++ps->cursor;
sp_scan3:
#line 132 "sexpr_parse.c.re"
			{ err = error(ps, "Unexpected char '%c'", *t); continue; }
#line 217 "sexpr_parse.c"
sp_scan4:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case '\t':
				case '\r':
				case ' ': goto sp_scan4;
				default: goto sp_scan5;
			}
sp_scan5:
#line 119 "sexpr_parse.c.re"
			{ continue; }
#line 229 "sexpr_parse.c"
sp_scan6:
			++ps->cursor;
#line 118 "sexpr_parse.c.re"
			{ ps->lineno++; continue; }
#line 234 "sexpr_parse.c"
sp_scan7:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case '!':
				case '$':
				case '%':
				case '&':
				case '*':
				case '+':
				case '-':
				case '.':
				case '/':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case ':':
				case '<':
				case '=':
				case '>':
				case '?':
				case '@':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '^':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z':
				case '~': goto sp_scan7;
				default: goto sp_scan8;
			}
sp_scan8:
#line 120 "sexpr_parse.c.re"
			{ push(ps, sp_symbol(ps, t, ps->cursor)); continue; }
#line 323 "sexpr_parse.c"
sp_scan9:
			yyaccept = 0;
			curr = (unsigned char)*(YYMARKER = ++ps->cursor);
			if (curr <= 0x00) goto sp_scan3;
			goto sp_scan25;
sp_scan10:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case ';': goto sp_scan30;
				default: goto sp_scan11;
			}
sp_scan11:
#line 130 "sexpr_parse.c.re"
			{ push_control(ps, *t); continue; }
#line 338 "sexpr_parse.c"
sp_scan12:
			++ps->cursor;
			goto sp_scan11;
sp_scan13:
			++ps->cursor;
#line 131 "sexpr_parse.c.re"
			{ err = close_enclosed(ps, *t); continue; }
#line 346 "sexpr_parse.c"
sp_scan14:
			++ps->cursor;
#line 126 "sexpr_parse.c.re"
			{ push(ps, sp_symbol(ps, t, ps->cursor)); continue; }
#line 351 "sexpr_parse.c"
sp_scan15:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case '@': goto sp_scan31;
				default: goto sp_scan11;
			}
sp_scan16:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case '0': goto sp_scan19;
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto sp_scan21;
				default: goto sp_scan17;
			}
sp_scan17:
#line 127 "sexpr_parse.c.re"
			{ push(ps, sp_symbol(ps, t, ps->cursor)); continue; }
#line 376 "sexpr_parse.c"
sp_scan18:
			yyaccept = 1;
			curr = (unsigned char)*(YYMARKER = ++ps->cursor);
			switch (curr) {
				case '.': goto sp_scan32;
				default: goto sp_scan11;
			}
sp_scan19:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto sp_scan33;
				default: goto sp_scan20;
			}
sp_scan20:
#line 123 "sexpr_parse.c.re"
			{ push(ps, sp_number(ps, t, ps->cursor, 10)); continue; }
#line 402 "sexpr_parse.c"
sp_scan21:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto sp_scan21;
				default: goto sp_scan20;
			}
sp_scan22:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case 0x00:
				case '\n': goto sp_scan23;
				default: goto sp_scan22;
			}
sp_scan23:
#line 117 "sexpr_parse.c.re"
			{ continue; }
#line 428 "sexpr_parse.c"
sp_scan24:
			curr = (unsigned char)*++ps->cursor;
sp_scan25:
			switch (curr) {
				case 0x00: goto sp_scan26;
				case '"': goto sp_scan27;
				case '\\': goto sp_scan29;
				default: goto sp_scan24;
			}
sp_scan26:
			ps->cursor = YYMARKER;
			switch (yyaccept) {
				case 0: goto sp_scan3;
				case 1: goto sp_scan11;
				default: goto sp_scan28;
			}
sp_scan27:
			++ps->cursor;
sp_scan28:
#line 121 "sexpr_parse.c.re"
			{ push(ps, sp_string(ps, t, ps->cursor)); continue; }
#line 450 "sexpr_parse.c"
sp_scan29:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case 0x00: goto sp_scan26;
				case '"': goto sp_scan35;
				case '\\': goto sp_scan29;
				default: goto sp_scan24;
			}
sp_scan30:
			++ps->cursor;
#line 129 "sexpr_parse.c.re"
			{ push_control(ps, ';'); continue; }
#line 463 "sexpr_parse.c"
sp_scan31:
			++ps->cursor;
#line 128 "sexpr_parse.c.re"
			{ push_control(ps, '@'); continue; }
#line 468 "sexpr_parse.c"
sp_scan32:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case '.': goto sp_scan36;
				default: goto sp_scan26;
			}
sp_scan33:
			curr = (unsigned char)*++ps->cursor;
			switch (curr) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto sp_scan33;
				default: goto sp_scan34;
			}
sp_scan34:
#line 122 "sexpr_parse.c.re"
			{ push(ps, sp_number(ps, t, ps->cursor, 8)); continue; }
#line 493 "sexpr_parse.c"
sp_scan35:
			yyaccept = 2;
			curr = (unsigned char)*(YYMARKER = ++ps->cursor);
			switch (curr) {
				case 0x00: goto sp_scan28;
				case '"': goto sp_scan27;
				case '\\': goto sp_scan29;
				default: goto sp_scan24;
			}
sp_scan36:
			++ps->cursor;
#line 125 "sexpr_parse.c.re"
			{ push(ps, sp_symbol(ps, t, ps->cursor)); continue; }
#line 507 "sexpr_parse.c"
		}
#line 133 "sexpr_parse.c.re"

        }
        int csptr = ps->csptr;
        while (csptr) {
                struct centry *c = ps->control_stack + csptr - 1;
                if (c->depth == -1)
                        break;
                if (c->unary)
                        err = error(ps, "Hanging Unary '%c'", c->what);
                else
                        err = error(ps, "Unterminated '%c'", c->what);
                csptr--;
        }
        return err < 0 ? err : ps->sptr;
}

#if SP_ERROR != 4
int sp_error(struct parse_state *ps, char *fname, int line, char *str)
{
        if (!SP_ERROR)
                return 0;
        if (fname)
                fprintf(stderr, "%s:%i: ", fname, line);
        else
                fprintf(stderr, "line %i: ", line);
        fprintf(stderr, "%s\n", str);
        if (SP_ERROR == 3)
                exit(1);
        return SP_ERROR == 2 ? -1 : 0;
}
#endif
